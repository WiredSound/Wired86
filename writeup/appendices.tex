\begin{landscape} \section{Example Instruction Decodings}
    \begin{table}[h]
        \resizebox{0.87\paperheight}{!} {\begin{tabular} { |*{11}{c|} } % 11 columns
            \hline
            Assembly & \multicolumn{3}{c}{Opcode Byte} & \multicolumn{3}{|c}{MOD-REG-RM Byte} & \multicolumn{2}{|c}{Displacement Byte(s)} & \multicolumn{2}{|c|}{Immediate Byte(s)} \\
            \hline
            Intel Syntax                            & Opcode                & D-bit (direction)     & W-bit (word)          & MOD                   & REG           & R/M               & Low           & High      & Low       & High \\
            \hline
            \texttt{add cx, bx}                     & \underline{000000}01  & 0                     & 1                     & 11                    & 011           & 001               & & & & \\
                                                    & add                   & REG is source         & word data size        & register addressing   & BX source     & CX destination    & & & & \\
            \hline
            \texttt{add al, [bx+5]}                 & \underline{000000}10  & 1                     & 0                     & 01                    & 000           & 111               & 00000101      & & & \\
                                                    & add                   & REG is destination    & byte data size        & byte displacement     & AL dest       & BX + displacement & displace by 5 & & & \\
            \hline
            \texttt{mov word [bp+0x1234], 0x5678}   & \underline{110001}11  & 1                     & 1                     & 10                    & 000           & 110               & 00110100      & 00010010  & 01111000  & 01010110 \\
                                                    & mov Ew, Iw            & irrelevant            & word data size        & word displacement     & unused        & BP + displacement & 0x34          & 0x12      & 0x78      & 0x56 \\
            \hline
        \end{tabular}}
        \caption{Table showing example instruction decodings.}
    \end{table}
\end{landscape}

\section{Instruction Set}
    \label{sec:instructset}
    \subsection{Instruction Arguments}
    \begin{table}[h]
        \begin{tabular} { | c | m{0.85\textwidth} | }
            \hline
            Argument & Meaning \\
            \hline
            G & General-purpose register specified by the REG component of the MOD-REG-R/M byte. \\
            \hline
            E & Either a general-purpose register (specified by the R/M component when in register addressing mode) or a memory address (with optional displacement from index). \\
            \hline
        \end{tabular}
    \end{table}

    \subsection{Instructions}
        Note that this is not a complete list of Intel 8086 instructions but rather a list of just those that are supported by this emulator.

    \begin{table}[h]
        \begin{tabular} { | c | c | c | c | m{0.38\textwidth} | }
            \hline
            Opcode & Assembly & Arguments & MOD-REG-R/M & Description \\
            \hline
            \texttt{000000dw} & \texttt{add} & G, E & \checkmark & Add two values without carrying. \\
            \hline
            \texttt{0000010w} & \texttt{add} & AL/AX, I & & Add two values without carrying using AL (when w=0) or AX (when w=1) and an immediate value. \\
            \hline
            \texttt{00000110} & \texttt{push} & ES & & Push the value of the extra segment register onto the stack. \\
            \hline
            \texttt{00000111} & \texttt{pop} & ES & & Pop value off the stack and store it in extra segment register. \\
            \hline
            \texttt{000100dw} & \texttt{and} & G, E & \checkmark & Perform bitwise AND operation. \\
            \hline
            \texttt{0010010w} & \texttt{add} & AL/AX, I & & Perform bitwise AND operation with first argument being AL or AX an the second an immediate value. \\
            \hline
            % ADC instructions...
            \hline
            \texttt{0010110} & \texttt{push} & SS & & Push stack segment register. \\
            \hline
            \texttt{0010111} & \texttt{pop} & SS & & Pop stack segment register. \\
            \hline
            % AND instructions...
            % XOR instructions...
            \texttt{0100000} & \texttt{inc} & AX & & Add 1 to AX register value. \\
            \hline
            \texttt{0100001} & \texttt{inc} & CX & & Add 1 to CX register value. \\
            \hline
            \texttt{0100010} & \texttt{inc} & DX & & Add 1 to DX register value. \\
            \hline
            \texttt{0100011} & \texttt{inc} & BX & & Add 1 to BX register value. \\
            \hline
            \texttt{0100100} & \texttt{inc} & SP & & Add 1 to stack pointer. \\
            \hline
            \texttt{0100101} & \texttt{inc} & BP & & Add 1 to base pointer. \\
            \hline
            \texttt{0100110} & \texttt{inc} & SI & & Add 1 to source index. \\
            \hline
            \texttt{0100111} & \texttt{inc} & DI & & Add 1 to destination index. \\
        \end{tabular}
    \end{table}